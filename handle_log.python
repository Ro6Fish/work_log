#!/usr/bin/env python

import datetime
import configparser
from os import path
import shutil
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

dir_path = path.dirname(path.realpath(__file__))

print('dir_path:%s' % path.join(dir_path, 'config.ini'))

conf = configparser.ConfigParser()

conf.read(path.join(dir_path, 'config.ini'))

# base_datetime = datetime.datetime.now()
base_datetime = datetime.datetime.strptime('2019-06-28', '%Y-%m-%d')


# 1. 获取log.md内容，分辨本周任务和下周计划组织到邮件内容中
# 2. 发送邮件
# 3. 拷贝log文件，并且改名，清空log里本周任务和下周计划内容

# 自动化

# 1. 每天18点30分执行脚本
# 2. 查看当天日期的节假日接口

# 获取当前日期
# 查看当前日期是否节假日，如果是则不做操作，如果不是则继续判断
# 判断前面日期如果是节假日则停止，并记录date1
# 判断后面日期如果是节假日则停止，并记录date2
# 格式化日期组织邮件标题
# 格式化日期组织文件名称


# 返回格式化后的当前时间+days天 返回datetime
def date_delay(days):
    days_delay = base_datetime + datetime.timedelta(days=days)
    return days_delay


# 是否是假日 true 是假日 false 不是假日
def is_holiday(date):
    date_format = date.strftime('%Y-%m-%d')

    holiday_list = ['2019-06-23', '2019-06-29']

    # 调用接口比对此日期是否是假日 date_format todo
    if date_format in holiday_list:
        return True

    return False


# 发送周报邮件
def send_mail(title):
    msg_from = conf.get('email', 'msg_from')
    passwd = conf.get('email', 'passwd')
    msg_to = conf.get('email', 'msg_to')
    cs_to = conf.get('email', 'cs_to')

    subject = title

    log_file = open('./log.md')
    read = log_file.read()
    log_file.close()

    msg_content = read

    content = MIMEText('<html>'
                       '<body>'
                       'Hi, Tom:<br>'
                       '<br>'
                       '这是本周的工作周报，请查阅。<br>'
                       '<br>'
                       '<div style=white-space:pre-line;>'
                       '%s'
                       '</div>'
                       '</body>'
                       '</html>' % msg_content,  # 邮件内容
                       'html',
                       'utf-8'
                       )

    msg = MIMEMultipart('related')
    msg['Subject'] = subject
    msg['From'] = msg_from
    msg['To'] = msg_to
    msg['Cc'] = cs_to
    msg.attach(content)

    try:
        s = smtplib.SMTP_SSL('smtp.mxhichina.com', 465)  # 邮件服务器及端口
        s.login(msg_from, passwd)
        s.sendmail(msg_from, msg_to.split(",") + cs_to.split(','), msg.as_string())
        print('%s发送成功' % title)
        return True
    except OSError:
        print('%s发送失败' % title)
    finally:
        s.quit()

    return False


# 判断是否需要执行脚本
def main():
    cur_date = date_delay(0)

    print('main():%s' % cur_date)

    # 判断当天日期是否是假期，如果是则什么都不做，如果不是则继续判断当前日期的后一天日期
    if not is_holiday(cur_date):
        # 当前日期的后一天日期如果不是假期则什么也不做，如果是假期则计算出当前时间以前最早不是假期的日期
        if is_holiday(date_delay(1)):

            i = 0
            before_date = date_delay(i)
            before_date_is_not_holiday = True

            while before_date_is_not_holiday:
                if is_holiday(date_delay(i)):
                    break
                else:
                    before_date = date_delay(i)
                    i -= 1

            # 解析上班开始日期和结束日期
            start_date = datetime.datetime.strftime(before_date, '%Y/%m/%d')
            end_date = datetime.datetime.strftime(cur_date, '%Y/%m/%d')

            title = '周报%s-%s' % (start_date, end_date)

            is_send = send_mail(title)

            if is_send:
                '2019_0623-0624'
                start_month = start_date = datetime.datetime.strftime(before_date, '%m%d')
                shutil.copy(path.join(dir_path, 'log.md'), path.join(dir_path, '%s_%s-%s' % (datetime.datetime.year,)))

            print("是否发送：%s" % is_send)

        else:
            print('当前日期不是假期，后天日期%s不是假期，不用发送周报' % datetime.datetime.strftime(date_delay(1), '%Y-%m-%d'))

    else:
        print('当前日期是假期，不用发送周报')


# 执行程序
main()
